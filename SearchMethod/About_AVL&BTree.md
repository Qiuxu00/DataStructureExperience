# 🌳 高级搜索树详解：AVL 树与 B 树

> **摘要**：本文档详细解析了内存型平衡二叉树 **AVL Tree** 与 磁盘型多路查找树 **B-Tree** 的核心原理、性质、旋转逻辑及应用场景对比。

---

## 📚 目录 (Table of Contents)

1. [AVL 树 (AVL Tree)](#1-avl-树-avl-tree)
    - [核心定义与性质](#11-核心定义与性质)
    - [平衡因子 (Balance Factor)](#12-平衡因子-balance-factor)
    - [四种旋转操作 (Rotations)](#13-四种旋转操作-rotations)
    - [插入与删除的平衡维护](#14-插入与删除的平衡维护)
2. [B 树 (B-Tree)](#2-b-树-b-tree)
    - [为什么需要 B 树？](#21-为什么需要-b-树)
    - [B 树的严格定义](#22-b-树的严格定义-基于最小度数-t)
    - [核心操作：分裂与合并](#23-核心操作分裂与合并)
    - [B 树 vs B+ 树](#24-拓展b-树-vs-b-树)
3. [总结对比 (Comparison)](#3-总结对比)

---

## 1. AVL 树 (AVL Tree)

**全称**：Adelson-Velsky and Landis Tree
**定位**：历史上第一种自平衡二叉查找树 (Self-balancing BST)。
**适用场景**：内存中数据查找，且**查找频率远高于插入/删除**的场景（因为维护平衡成本高）。

### 1.1 核心定义与性质

1.  **BST 性质**：满足二叉查找树的所有特性（左 < 根 < 右）。
2.  **高度平衡**：对于树中**任意**节点，其左子树和右子树的高度差的绝对值不超过 1。
3.  **时间复杂度**：查找、插入、删除均维持在 $O(\log N)$。

### 1.2 平衡因子 (Balance Factor)

这是判断 AVL 树是否失衡的唯一指标。

$$BF(node) = Height(node->left) - Height(node->right)$$

| BF 值 | 状态 | 说明 |
| :---: | :---: | :--- |
| **0** | 完美平衡 | 左右子树等高 |
| **1 / -1** | 平衡 | 允许范围内的高度差 |
| **> 1** | **失衡 (左重)** | 左子树过高，需右旋 |
| **< -1** | **失衡 (右重)** | 右子树过高，需左旋 |

### 1.3 四种旋转操作 (Rotations)

当插入或删除导致 $|BF| > 1$ 时，必须进行旋转。

#### A. LL 型 (左左) $\rightarrow$ 右单旋 (Right Rotation)
* **触发条件**：失衡点 $BF > 1$ 且 左孩子 $BF \ge 0$。
* **场景**：在左孩子的左侧插入了节点。
* **操作**：
    ```
         A (失衡)           B (新根)
        / \               /   \
       B   E    ==>      C     A
      / \                     / \
     C   D                   D   E
    ```

#### B. RR 型 (右右) $\rightarrow$ 左单旋 (Left Rotation)
* **触发条件**：失衡点 $BF < -1$ 且 右孩子 $BF \le 0$。
* **场景**：在右孩子的右侧插入了节点。
* **操作**：
    ```
       A (失衡)             B (新根)
      / \                 /   \
     E   B      ==>      A     C
        / \             / \
       D   C           E   D
    ```

#### C. LR 型 (左右) $\rightarrow$ 先左旋后右旋 (Left-Right Rotation)
* **触发条件**：失衡点 $BF > 1$ 且 左孩子 $BF < 0$。
* **场景**：在左孩子的右侧插入了节点（形成拐角）。
* **操作**：
    1. 对左孩子进行**左旋** $\rightarrow$ 变成 LL 型。
    2. 对失衡点进行**右旋**。

#### D. RL 型 (右左) $\rightarrow$ 先右旋后左旋 (Right-Left Rotation)
* **触发条件**：失衡点 $BF < -1$ 且 右孩子 $BF > 0$。
* **场景**：在右孩子的左侧插入了节点（形成拐角）。
* **操作**：
    1. 对右孩子进行**右旋** $\rightarrow$ 变成 RR 型。
    2. 对失衡点进行**左旋**。

### 1.4 插入与删除的平衡维护

| 操作 | 描述 | 旋转次数 |
| :--- | :--- | :--- |
| **插入 (Insert)** | 插入叶子节点后向上回溯。 | **最多 1 次** (单旋或双旋)。旋转后整棵树高度恢复，无需继续回溯。 |
| **删除 (Erase)** | 删除节点后（可能需替换），向上回溯。 | **可能 $O(\log N)$ 次**。旋转可能导致子树变矮，引发上层祖先失衡，需一路回溯到根。 |

---

## 2. B 树 (B-Tree)

**定位**：多路平衡查找树 (Multi-way Balanced Search Tree)。
**适用场景**：磁盘文件系统、数据库索引（如 MongoDB, MySQL）。
**核心思想**：通过增加节点的子节点数量，降低树的高度，从而减少磁盘 I/O 次数。

### 2.1 为什么需要 B 树？

* **矮胖结构**：AVL 树存 1000 万数据需 24 层（24 次 I/O）；B 树通常只需 3 层（3 次 I/O）。
* **局部性原理**：一个节点大小通常设计为磁盘页大小（如 4KB），一次 I/O 读入多个关键字，利用率极高。

### 2.2 B 树的严格定义 (基于最小度数 $t$)

设 $t \ge 2$ 为 B 树的最小度数 (Minimum Degree)：

1.  **节点键值数**：
    * 根节点：至少 1 个关键字。
    * 非根节点：至少 $t-1$ 个，至多 $2t-1$ 个。
2.  **子节点数**：
    * 非叶子节点：包含 $n$ 个关键字，则必有 $n+1$ 个子节点。
    * 范围：$[t, 2t]$。
3.  **叶子节点**：所有叶子节点都在**同一层**（绝对平衡）。
4.  **排序**：节点内关键字有序，且分隔子树范围。

> **示例**：当 $t=3$ (3 阶 B 树)
> * 每个节点最多 5 个 key ($2*3 - 1$)。
> * 每个节点最多 6 个 child。
> * 除根外，最少 2 个 key。

### 2.3 核心操作：分裂与合并

#### A. 插入 (Insert) - 核心是“分裂 (Split)”
新元素**永远插入在叶子节点**。

1.  **未满直接插**：如果叶子节点关键字数 $< 2t-1$，按序插入。
2.  **满了则分裂**：
    * 将节点中间的关键字（中位数）**上提 (Promote)** 到父节点。
    * 原节点一分为二。
    * 如果父节点也满了，继续向上分裂。
    * **特殊**：如果根节点分裂，树高度 +1。

#### B. 删除 (Delete) - 核心是“借位 (Borrow)”与“合并 (Merge)”
删除非叶子节点通常转化为删除前驱/后继（叶子节点），所以最终也是在处理叶子。

1.  **兄弟富裕 ( > t-1 )**：
    * **旋转借位**：父节点下移一个给当前节点，兄弟节点上移一个给父节点。
2.  **兄弟贫穷 ( = t-1 )**：
    * **合并**：将（当前节点 + 父节点分隔值 + 兄弟节点）合并成一个新节点。
    * 父节点关键字 -1，若父节点因此下溢，继续向上调整。
    * **特殊**：如果根节点关键字被借空，树高度 -1。

### 2.4 拓展：B 树 vs B+ 树

| 特性 | B 树 | B+ 树 (数据库常用) |
| :--- | :--- | :--- |
| **数据存储** | 所有节点都存 Data | **只有叶子节点存 Data**，非叶子只存索引(Key) |
| **叶子链表** | 无 | 叶子节点通过指针相连 (适合范围查询) |
| **查找稳定性** | 最好 $O(1)$，最差 $O(\log N)$ | 必须走到叶子，稳定 $O(\log N)$ |

---

## 3. 总结对比

| 维度 | AVL 树 | B 树 |
| :--- | :--- | :--- |
| **结构类型** | 二叉树 (Binary) | 多路树 (Multi-way) |
| **平衡限制** | 严格高度差 $\le 1$ | 绝对平衡 (叶子在同一层) |
| **节点利用率** | 低 (存1个值+2指针) | 高 (存页大小数据+多指针) |
| **树的高度** | 较高 ($O(\log_2 N)$) | 极低 ($O(\log_t N)$) |
| **I/O 性能** | 差 (多次随机读写) | 优 (连续读写，次数少) |
| **核心操作** | 旋转 (Rotate) | 分裂 (Split) / 合并 (Merge) |
| **典型应用** | C++ `std::map` (红黑树变种), 内存查找 | MySQL 索引, MongoDB, 文件系统 |