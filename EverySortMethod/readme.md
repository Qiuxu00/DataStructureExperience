# 所有排序算法的标准代码及注释

## 插入排序：

- 注意插入排序的插入过程，是总后往前的查找过程，你就会发现每次只有原来位置的数字比自己大，那么直接让他后移，这是一个高效的算法
- 记住要有一个索引来记录最后一次被排序的元素的位置

## 折半插入排序：

- 这个算法的查找过程是logn的时间复杂度，但是仅仅又来查找位置在哪里，所以移动的过程仍然是n的时间复杂度，从low开始往后到最后一个被排序过的元素，也是从后向前排序

## Shell希尔排序（n，n^2,n^1.3~n^1.5）（已经有序，每组逆序，平均）

- 一开始设置gap为n/2，一直缩减到0位置
- 注意看第一个循环内部的4行注释
- 他是这样的，三次循环：
  1. 最外层缩减gap
  2. 次外层是在定下gap的时候，将插入排序的从后往前的起点一直往后挪，也就是第一次是i=gap，后面开始就是i++直到n
  3. 最内层就是插入排序的循环，但是**一组的跳度是gap**，也就是从i开始一直减去gap，直到**i-gap<0**，并且只有在**插入排序循环条件**（也就是下一个元素的大小大于自己，要向前移动的时候，才会接着向下移动）成立的情况下，循环接着进行，仔细看循环条件

## 冒泡排序

简单，记得加入一个是否在本轮交换过的Flag，如果没有交换过（及后一个一直比前一个大），说明已经排序完成了，不需要再继续

## 快速排序

- 记住哨兵数一定要存起来（也就是索引Left）
- 先右后左，直到相遇
- 记住递归终止条件是L>=R
- 赋值法比交换法效率更高，所以你需要维护一个pivot
  1. 右边出现小于的，左边直接赋值为右边，左边加1维持从下一个开始
  2. 左边出现大于的，跟上面共轭操作
  3. 直到最后相遇，肯定是有一方在之前已经赋值过了
     - 如果是左边静止，右边移动至相遇，那么右边之前肯定赋值成左边了，所以可以直接将pivot复制到左右
     - 右边同理
- 记得循环条件的作用域，每个条件都要带上low<high

## 堆排序

小心建堆过程：一定是大顶堆

记得只需要一个siftdown函数就可以，参数为size和起始位置索引

1. 从最后一个”非叶子节点“开始，采用siftdown来实现建堆
2. 最后一个非叶子节点的索引为size/2-1
3. 建堆之后，每次交换，size-1，每次从头siftdown这样实现每次[0]都为最大值

## 二路归并排序

```cpp
    int i = left;    // 左半区间的起点
    int j = mid + 1; // 右半区间的起点
    int k = 0;       // 临时数组的索引
```

也没啥，记得最后将辅助数组中的所有元素赋值回原数组中

```cpp
// 3. 处理剩余元素
    // 如果左边还有剩，全部抄过去
    while (i <= mid)
    {
        temp[k++] = arr[i++];
    }
    // 如果右边还有剩，全部抄过去
    while (j <= right)
    {
        temp[k++] = arr[j++];
    }

    // 4. 将排序好的临时数组搬回原数组
    // 注意原数组是从 left 开始的
    for (int p = 0; p < temp.size(); ++p)
    {
        arr[left + p] = temp[p];
    }
```

